diff --git a/ios/bottom-tabs/RNSTabBarAppearanceCoordinator.mm b/ios/bottom-tabs/RNSTabBarAppearanceCoordinator.mm
index 6e2f7f17055b4ccba83314c458726a032f23ae4a..a24a6f1bef5e563f0898e3eaa41a0c1a59662e18 100644
--- a/ios/bottom-tabs/RNSTabBarAppearanceCoordinator.mm
+++ b/ios/bottom-tabs/RNSTabBarAppearanceCoordinator.mm
@@ -3,7 +3,6 @@
 #import <React/RCTImageLoader.h>
 #import "RCTConvert+RNSBottomTabs.h"
 #import "RNSConversions.h"
-#import "RNSTabBarController.h"
 #import "RNSTabsScreenViewController.h"
 
 @implementation RNSTabBarAppearanceCoordinator
@@ -20,10 +19,6 @@
   // Step 1 - configure host-specific appearance
   tabBar.tintColor = hostComponentView.tabBarTintColor;
 
-  // Set tint color for iPadOS tab bar. This is the official way recommended by Apple:
-  // https://developer.apple.com/forums/thread/761056?answerId=798245022#798245022
-  hostComponentView.controller.view.tintColor = hostComponentView.tabBarTintColor;
-
   if (tabScreenCtrls == nil) {
     return;
   }
@@ -205,7 +200,7 @@
       itemStateAppearanceProps[@"tabBarItemTitleFontWeight"] != nil ||
       itemStateAppearanceProps[@"tabBarItemTitleFontStyle"] != nil) {
     titleTextAttributes[NSFontAttributeName] =
-        [RCTFont updateFont:tabBarItemStateAppearance.titleTextAttributes[NSFontAttributeName]
+        [RCTFont updateFont:nil
                  withFamily:itemStateAppearanceProps[@"tabBarItemTitleFontFamily"]
                        size:itemStateAppearanceProps[@"tabBarItemTitleFontSize"]
                      weight:itemStateAppearanceProps[@"tabBarItemTitleFontWeight"]
diff --git a/src/components/bottom-tabs/BottomTabsScreen.tsx b/src/components/bottom-tabs/BottomTabsScreen.tsx
index a3ab42090b7a90542a260935fc8d63cadc4cfc23..1b17293ee41d5a007d937a4eecda784c9dc6503c 100644
--- a/src/components/bottom-tabs/BottomTabsScreen.tsx
+++ b/src/components/bottom-tabs/BottomTabsScreen.tsx
@@ -4,8 +4,6 @@ import React from 'react';
 import { Freeze } from 'react-freeze';
 import {
   Image,
-  ImageResolvedAssetSource,
-  Platform,
   StyleSheet,
   findNodeHandle,
   processColor,
@@ -27,13 +25,9 @@ import type {
   BottomTabsScreenItemStateAppearance,
   BottomTabsScreenProps,
   EmptyObject,
+  Icon,
 } from './BottomTabsScreen.types';
 import { bottomTabsDebugLog } from '../../private/logging';
-import type {
-  PlatformIcon,
-  PlatformIconAndroid,
-  PlatformIconIOS,
-} from '../../types';
 
 /**
  * EXPERIMENTAL API, MIGHT CHANGE W/O ANY NOTICE
@@ -61,6 +55,7 @@ function BottomTabsScreen(props: BottomTabsScreenProps) {
     isFocused = false,
     freezeContents,
     icon,
+    iconResource,
     selectedIcon,
     standardAppearance,
     scrollEdgeAppearance,
@@ -124,6 +119,16 @@ function BottomTabsScreen(props: BottomTabsScreenProps) {
 
   const iconProps = parseIconsToNativeProps(icon, selectedIcon);
 
+  let parsedIconResource;
+  if (iconResource) {
+    parsedIconResource = Image.resolveAssetSource(iconResource);
+    if (!parsedIconResource) {
+      console.error(
+        '[RNScreens] failed to resolve an asset for bottom tab icon',
+      );
+    }
+  }
+
   return (
     <BottomTabsScreenNativeComponent
       collapsable={false}
@@ -133,6 +138,11 @@ function BottomTabsScreen(props: BottomTabsScreenProps) {
       onWillDisappear={onWillDisappearCallback}
       onDidDisappear={onDidDisappearCallback}
       isFocused={isFocused}
+      // I'm keeping undefined as a fallback if `Image.resolveAssetSource` has failed for some reason.
+      // It won't render any icon, but it will prevent from crashing on the native side which is expecting
+      // ReadableMap. Passing `iconResource` directly will result in crash, because `require` API is returning
+      // double as a value.
+      iconResource={parsedIconResource || undefined}
       {...iconProps}
       standardAppearance={mapAppearanceToNativeProp(standardAppearance)}
       scrollEdgeAppearance={mapAppearanceToNativeProp(scrollEdgeAppearance)}
@@ -236,42 +246,7 @@ function shouldFreezeScreen(
   return !nativeViewVisible;
 }
 
-function parseAndroidIconToNativeProps(icon: PlatformIconAndroid | undefined): {
-  imageIconResource?: ImageResolvedAssetSource;
-  drawableIconResourceName?: string;
-} {
-  if (!icon) {
-    return {};
-  }
-
-  let parsedIconResource;
-  if (icon.type === 'imageSource') {
-    parsedIconResource = Image.resolveAssetSource(icon.imageSource);
-    if (!parsedIconResource) {
-      console.error(
-        '[RNScreens] failed to resolve an asset for bottom tab icon',
-      );
-    }
-
-    return {
-      // I'm keeping undefined as a fallback if `Image.resolveAssetSource` has failed for some reason.
-      // It won't render any icon, but it will prevent from crashing on the native side which is expecting
-      // ReadableMap. Passing `iconResource` directly will result in crash, because `require` API is returning
-      // double as a value.
-      imageIconResource: parsedIconResource || undefined,
-    };
-  } else if (icon.type === 'drawableResource') {
-    return {
-      drawableIconResourceName: icon.name,
-    };
-  } else {
-    throw new Error(
-      '[RNScreens] Incorrect icon format for Android. You must provide `imageSource` or `drawableResource`.',
-    );
-  }
-}
-
-function parseIOSIconToNativeProps(icon: PlatformIconIOS | undefined): {
+function parseIconToNativeProps(icon: Icon | undefined): {
   iconType?: IconType;
   iconImageSource?: ImageSourcePropType;
   iconSfSymbolName?: string;
@@ -280,83 +255,69 @@ function parseIOSIconToNativeProps(icon: PlatformIconIOS | undefined): {
     return {};
   }
 
-  if (icon.type === 'sfSymbol') {
+  if ('sfSymbolName' in icon) {
+    // iOS-specific: SFSymbol usage
     return {
       iconType: 'sfSymbol',
-      iconSfSymbolName: icon.name,
+      iconSfSymbolName: icon.sfSymbolName,
     };
-  } else if (icon.type === 'imageSource') {
+  } else if ('imageSource' in icon) {
     return {
       iconType: 'image',
       iconImageSource: icon.imageSource,
     };
-  } else if (icon.type === 'templateSource') {
+  } else if ('templateSource' in icon) {
+    // iOS-specifig: image as a template usage
     return {
       iconType: 'template',
       iconImageSource: icon.templateSource,
     };
   } else {
+    // iOS-specific: SFSymbol, image as a template usage
     throw new Error(
-      '[RNScreens] Incorrect icon format for iOS. You must provide `sfSymbol`, `imageSource` or `templateSource`.',
+      '[RNScreens] Incorrect icon format. You must provide sfSymbolName, imageSource or templateSource.',
     );
   }
 }
 
 function parseIconsToNativeProps(
-  icon: PlatformIcon | undefined,
-  selectedIcon: PlatformIconIOS | undefined,
+  icon: Icon | undefined,
+  selectedIcon: Icon | undefined,
 ): {
-  imageIconResource?: ImageResolvedAssetSource;
-  drawableIconResourceName?: string;
   iconType?: IconType;
   iconImageSource?: ImageSourcePropType;
   iconSfSymbolName?: string;
   selectedIconImageSource?: ImageSourcePropType;
   selectedIconSfSymbolName?: string;
 } {
-  if (Platform.OS === 'android') {
-    const androidNativeProps = parseAndroidIconToNativeProps(
-      icon?.android || icon?.shared,
+  const { iconImageSource, iconSfSymbolName, iconType } =
+    parseIconToNativeProps(icon);
+  const {
+    iconImageSource: selectedIconImageSource,
+    iconSfSymbolName: selectedIconSfSymbolName,
+    iconType: selectedIconType,
+  } = parseIconToNativeProps(selectedIcon);
+
+  if (
+    iconType !== undefined &&
+    selectedIconType !== undefined &&
+    iconType !== selectedIconType
+  ) {
+    throw new Error('[RNScreens] icon and selectedIcon must be same type.');
+  } else if (iconType === undefined && selectedIconType !== undefined) {
+    // iOS-specific: UIKit requirement
+    throw new Error(
+      '[RNScreens] To use selectedIcon prop, the icon prop must also be provided.',
     );
-    return {
-      ...androidNativeProps,
-    };
   }
 
-  if (Platform.OS === 'ios') {
-    const { iconImageSource, iconSfSymbolName, iconType } =
-      parseIOSIconToNativeProps(icon?.ios || icon?.shared);
-
-    const {
-      iconImageSource: selectedIconImageSource,
-      iconSfSymbolName: selectedIconSfSymbolName,
-      iconType: selectedIconType,
-    } = parseIOSIconToNativeProps(selectedIcon);
-
-    if (
-      iconType !== undefined &&
-      selectedIconType !== undefined &&
-      iconType !== selectedIconType
-    ) {
-      throw new Error('[RNScreens] icon and selectedIcon must be same type.');
-    } else if (iconType === undefined && selectedIconType !== undefined) {
-      // iOS-specific: UIKit requirement
-      throw new Error(
-        '[RNScreens] To use selectedIcon prop, the icon prop must also be provided.',
-      );
-    }
-
-    return {
-      iconType,
-      iconImageSource,
-      iconSfSymbolName,
-      selectedIconImageSource,
-      selectedIconSfSymbolName,
-    };
-  }
-
-  // Fallback for other platforms
-  return {};
+  return {
+    iconType,
+    iconImageSource,
+    iconSfSymbolName,
+    selectedIconImageSource,
+    selectedIconSfSymbolName,
+  };
 }
 
 export default BottomTabsScreen;
diff --git a/src/components/bottom-tabs/BottomTabsScreen.types.ts b/src/components/bottom-tabs/BottomTabsScreen.types.ts
index 358c9e2e5c3a3e48dd3654f51bb0af1b6e1a043e..bc1bb92afbcf3a1bc5b982f83c1934efa464a7fd 100644
--- a/src/components/bottom-tabs/BottomTabsScreen.types.ts
+++ b/src/components/bottom-tabs/BottomTabsScreen.types.ts
@@ -1,11 +1,11 @@
 import type {
   ColorValue,
+  ImageSourcePropType,
   NativeSyntheticEvent,
   TextStyle,
   ViewProps,
 } from 'react-native';
 import { ScrollEdgeEffect } from '../shared/types';
-import type { PlatformIcon, PlatformIconIOS } from '../../types';
 
 export type EmptyObject = Record<string, never>;
 
@@ -18,6 +18,24 @@ export type LifecycleStateChangeEvent = Readonly<{
   newState: number;
 }>;
 
+// iOS-specific: SFSymbol usage
+export interface SFIcon {
+  sfSymbolName: string;
+}
+
+// iOS-specific
+export interface ImageIcon {
+  imageSource: ImageSourcePropType;
+}
+
+// iOS-specific: image as a template usage
+export interface TemplateIcon {
+  templateSource: ImageSourcePropType;
+}
+
+// iOS-specific: SFSymbol, image as a template usage
+export type Icon = SFIcon | ImageIcon | TemplateIcon;
+
 // iOS-specific
 export type BottomTabsScreenBlurEffect =
   | 'none'
@@ -304,41 +322,27 @@ export interface BottomTabsScreenProps {
    * @platform android, ios
    */
   badgeValue?: string;
+
+  // #region Android-only appearance
   /**
    * @summary Specifies the icon for the tab bar item.
    *
-   * You can define an icon separately for each platform (in `ios` and `android`)
-   * or define a default icon in `shared`. The shared icon will be used on both
-   * platforms unless it is overridden by a platform-specific definition
-   * in `ios` or `android`.
-   *
-   * Supported values:
-   *
-   * Shared (both iOS and Android):
-   * - `{ type: 'imageSource', imageSource }`
-   *   Uses an image from the provided resource.
+   * Accepts a string corresponding to the resource name. Initially searches within
+   * the app's drawable resources. If no matching resource is found, it defaults to
+   * searching within the Android's drawable resources.
    *
-   *   Remarks: `imageSource` type doesn't support SVGs on Android.
-   *   For loading SVGs use `drawableResource` type.
-   *
-   * iOS-only:
-   * - `{ type: 'sfSymbol', name }`
-   *   Uses an SF Symbol with the specified name.
-   * - `{ type: 'templateSource', templateSource }`
-   *   Uses the provided image as a template image.
-   *   The icon color will depend on the current state
-   *   of the tab bar item and icon color-related props.
-   *
-   * Android-only:
-   * - `{ type: 'drawableResource', name }`
-   *   Uses a drawable resource with the given name.
+   * @platform android
+   */
+  iconResourceName?: string;
+  /**
+   * @summary Specifies the icon for the tab bar item.
    *
-   *   Remarks: Requires passing a drawable to resources via Android Studio.
+   * Accepts a path to the external image asset. As for now, it respects an image from local assets
+   * and passed by `source.uri` property.
    *
-   * On iOS, if no `selectedIcon` is provided, this icon will also
-   * be used as the selected state icon.
+   * @platform android
    */
-  icon?: PlatformIcon;
+  iconResource?: ImageSourcePropType;
   /**
    * @summary Specifies supported orientations for the tab screen.
    *
@@ -426,16 +430,34 @@ export interface BottomTabsScreenProps {
    * @platform ios
    */
   scrollEdgeAppearance?: BottomTabsScreenAppearance;
+  /**
+   * @summary Specifies the icon for the tab bar item.
+   *
+   * The following values are currently supported:
+   *
+   * - an object with `sfSymbolName` - will attempt to use SF
+   *   Symbol with given name,
+   * - an object with `imageSource` - will attempt to use image
+   *   from provided resource,
+   * - an object with `templateSource` - will attempt to use image
+   *   from provided resource as template (the color of the image will
+   *   depend on props related to icon color and tab bar item's state).
+   *
+   * If no `selectedIcon` is provided, it will also be used as `selectedIcon`.
+   *
+   * @platform ios
+   */
+  icon?: Icon;
   /**
    * @summary Specifies the icon for tab bar item when it is selected.
    *
-   * Supports the same values as `icon` property for iOS.
+   * Supports the same values as `icon` property.
    *
    * To use `selectedIcon`, `icon` must also be provided.
    *
    * @platform ios
    */
-  selectedIcon?: PlatformIconIOS;
+  selectedIcon?: Icon;
   /**
    * @summary System-provided tab bar item with predefined icon and title
    *
